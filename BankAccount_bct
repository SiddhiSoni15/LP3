BankAccount.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title BankAccount
 * @dev A simple and secure smart contract to simulate a bank account system.
 * Supports deposit, withdraw, and balance inquiry with safety checks.
 */
contract BankAccount {
    // Mapping to store user balances
    mapping(address => uint256) private balances;

    // Events for logging
    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);

    /**
     * @dev Deposit ETH into your account.
     */
    function deposit() external payable {
        require(msg.value > 0, "Deposit amount must be greater than 0");
        balances[msg.sender] += msg.value;
        emit Deposited(msg.sender, msg.value);
    }

    /**
     * @dev Withdraw ETH from your account.
     * Uses checks-effects-interactions pattern for safety.
     */
    function withdraw(uint256 amount) external {
        uint256 userBalance = balances[msg.sender];
        require(amount > 0, "Amount must be greater than 0");
        require(userBalance >= amount, "Insufficient balance");

        // Effects
        balances[msg.sender] = userBalance - amount;

        // Interaction (safe transfer)
        payable(msg.sender).transfer(amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     * @dev Get your balance.
     */
    function getBalance() external view returns (uint256) {
        return balances[msg.sender];
    }

    /**
     * @dev Fallback & receive functions to handle accidental ETH transfers.
     */
    receive() external payable {
        balances[msg.sender] += msg.value;
        emit Deposited(msg.sender, msg.value);
    }

    fallback() external payable {
        balances[msg.sender] += msg.value;
        emit Deposited(msg.sender, msg.value);
    }
}



theory 
A Smart Contract is a self-executing piece of code stored on the Ethereum blockchain, which automatically enforces and executes the terms of an agreement.
In this experiment, we design a Bank Account smart contract that allows a customer to deposit, withdraw, and check balance securely.
Smart contracts are written in Solidity, a contract-oriented programming language for Ethereum.
The contract stores each user’s balance in a mapping data structure.
When users deposit funds, their balances increase; when they withdraw, the contract checks if they have sufficient funds before transferring the amount.
The contract runs on a test network (like Sepolia, Goerli, or Remix’s JavaScript VM) for development and testing without real Ether.
Each function call and transaction is recorded on the blockchain, ensuring transparency and immutability.
This simple banking contract demonstrates the foundational concepts of decentralized finance (DeFi) and Ethereum state management.

Concept	Description
msg.sender	Address of the account calling the function
msg.value	Amount of Ether sent in the transaction
payable	    Keyword that allows a function to receive Ether
mapping	    Stores key-value pairs (address → balance)
require()	Ensures conditions are met before execution

The Bank Account Smart Contract was successfully implemented and tested on the Ethereum test network using Remix IDE.
It allows customers to securely deposit, withdraw, and check their balances on the blockchain.
The contract ensures that no user can withdraw more than their balance using the require() condition.
Since all operations are executed on a decentralized blockchain, the system provides transparency, immutability, and security.
This experiment demonstrates the basic functionality of financial transactions using smart contracts in decentralized applications (DApps).



